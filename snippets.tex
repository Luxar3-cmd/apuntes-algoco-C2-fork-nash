\section{Snippets}

\subsection{Comparador}
\label{subsec:comparador}
% Explicacion
Un comparador es una función que se utiliza para ordenar los elementos de un contenedor de una forma específica. En C++, los comparadores son funciones que retornan un valor booleano siendo \texttt{true} si el primer argumento debe ir antes que el segundo y \texttt{false} en caso contrario.

\subsubsection*{Ejemplo:}
\begin{lstlisting}
bool cmp(int a, int b) {
  return a > b;
}
\end{lstlisting}
\subsubsection*{Ejemplo con funciones lambda:}
\begin{lstlisting}
// Ordena los elementos de un objeto edge en orden ascendente en funcion del peso.
sort(edge.begin(), edge.end(), [](auto &a, auto &b) {
  return a.w < b.w;
});
// Declara un comparador a traves de una funcion lambda
auto cmp = [](int a, int b) {
  return a > b;
};
\end{lstlisting}

\subsection{std::sort}
\label{subsec:std_sort}
% Explicacion
La función \texttt{std::sort} ordena los elementos de un contenedor en orden ascendente. Si se desea ordenar en orden descendente, se puede utilizar un comparador (ver \ref{subsec:comparador}).

\subsubsection*{Implementacion:}
\begin{lstlisting}
std::sort(v.begin(), v.end(), comp);
\end{lstlisting}

\subsection{std::stable\_sort}
\label{subsec:std_stable_sort}
% Explicacion
La función \texttt{std::stable\_sort} ordena los elementos de un contenedor en orden ascendente. A diferencia de \texttt{std::sort}, esta función mantiene el orden relativo de los elementos que son iguales.

\subsubsection*{Implementacion:}
\begin{lstlisting}
std::stable_sort(v.begin(), v.end(), comp);
\end{lstlisting}

\subsection{std::binary\_search}
\label{subsec:std_binary_search}
% Explicacion
La función \texttt{std::binary\_search} busca un elemento en un contenedor ordenado. Retorna \texttt{true} si el elemento se encuentra en el contenedor y \texttt{false} en caso contrario.

\subsubsection*{Implementacion:}
\begin{lstlisting}
std::binary_search(v.begin(), v.end(), x);
\end{lstlisting}

\subsection{std::lower\_bound}
\label{subsec:std_lower_bound}
% Explicacion
La función \texttt{std::lower\_bound} retorna un iterador al primer elemento en un contenedor cuyo comparador retorne \texttt{false} para el valor dado. Es decir, el primer elemento que es mayor o igual al valor dado.

\subsubsection*{Implementacion:}
\begin{lstlisting}
std::lower_bound(v.begin(), v.end(), x, comp);
\end{lstlisting}

\subsubsection*{Ejemplo de busqueda:}
\begin{lstlisting}
  std::vector<int> data = {1, 3, 3, 5, 7, 9};
  int target = 4;
  auto it = std::lower_bound(data.begin(), data.end(), target);
  if (it != data.end() && *it == target) {
    std::cout << "Element found at index " << it - data.begin() << std::endl;
  } else {
    std::cout << "Element not found" << std::endl;
  }
\end{lstlisting}

\subsection{std::upper\_bound}
\label{subsec:std_upper_bound}
% Explicacion
La función \texttt{std::upper\_bound} retorna un iterador al primer elemento en un contenedor cuyo comparador retorne \texttt{true} para el valor dado. Es decir el primer elemento que es mayor estricto al valor dado.

\subsubsection*{Implementacion:}
\begin{lstlisting}
std::upper_bound(v.begin(), v.end(), x, comp);
\end{lstlisting}



\subsection{std::reverse}
\label{subsec:std_reverse}
% Explicacion
La función \texttt{std::reverse} invierte el orden de los elementos de un contenedor en $O(n)$. 

\subsubsection*{Implementacion:}
\begin{lstlisting}
std::reverse(v.begin(), v.end());
\end{lstlisting}

\subsection{std::next\_permutation}
\label{subsec:std_next_permutation}
% Explicacion
La función \texttt{std::next\_permutation} reordena los elementos de un contenedor en la siguiente permutación lexicográfica. Retorna \texttt{true} si la siguiente permutación existe y \texttt{false} en caso contrario. 


\subsubsection*{Implementacion:}
\begin{lstlisting}
std::next_permutation(v.begin(), v.end());
\end{lstlisting}


Para obtener todas las permutaciones de un contenedor, se puede utilizar un ciclo \texttt{do-while} asegurandose que este este ordenado en orden ascendente antes de empezar. 

\begin{lstlisting}
std::sort(v.begin(), v.end());

do {
  // Procesar la permutacion
} while(std::next_permutation(v.begin(), v.end()));
\end{lstlisting}

\subsection{std::prev\_permutation}
\label{subsec:std_prev_permutation}
% Explicacion
La función \texttt{std::prev\_permutation} reordena los elementos de un contenedor en la permutación lexicográfica anterior. Retorna \texttt{true} si la permutación anterior existe y \texttt{false} en caso contrario. 

\subsubsection*{Implementacion:}
\begin{lstlisting}
std::prev_permutation(v.begin(), v.end());
\end{lstlisting}

Para obtener todas las permutaciones de un contenedor, se puede utilizar un ciclo \texttt{do-while} asegurandose que este este ordenado en orden descendente antes de empezar.
