\section{Estructuras de datos}
\label{sec:estructuras_de_datos}

\subsection{std::array}
\label{subsec:std_array}
Contenedor de tamaño fijo. 

\subsubsection*{Formas de definirlo:}
\begin{itemize}
  \item Syntaxis genérica: \texttt{type name [size];}
  \item Inicializar con ceros: \texttt{int baz [5] = \{ \};}
  \item Inicializar con valores: \texttt{int foo [5] = \{ 16, 2, 77, 40, 12071 \};}
\end{itemize}

\subsection{std::vector}
\label{subsec:std_vector}
Contenedor dinámico de tamaño variable.

\subsubsection*{Formas de definirlo:}
\begin{itemize}
  \item Syntaxis genérica: \texttt{std::vector<type> name;}
  \item Inicializar con ceros: \texttt{std::vector<int> v(n,0);}
  \item Inicializar con valores: \texttt{std::vector<int> foo \{ 16, 2, 77, 40, 12071 \};}
\end{itemize}

\subsubsection*{Funciones miembro:}
\begin{itemize}
  \item \texttt{push\_back(value)}: Agrega un elemento al final [O(1)].
  \item \texttt{pop\_back()}: Elimina el último elemento [O(1)].
  \item \texttt{size()}: Retorna la cantidad de elementos [O(1)].
  \item \texttt{empty()}: Retorna \texttt{true} si está vacío [O(1)].
  \item \texttt{clear()}: Elimina todos los elementos [O(n)].
  \item \texttt{front()}: Retorna el primer elemento [O(1)].
  \item \texttt{back()}: Retorna el último elemento [O(1)].
  \item \texttt{insert(iterator, value)}: Inserta un elemento en la posición indicada [O(n)].
\end{itemize}

\subsubsection*{Extras: }
\begin{itemize}
  \item Inicializar copiando un vector: \texttt{std::vector<int> bar(foo);}
  \item Ciclo for each: \texttt{for (auto \&x : v) \{ \}}
  \item Uso de iteradores: \texttt{std::vector<int>::iterator it;}
  \begin{itemize}
    \item Ejemplo con for: \texttt{for (it = v.begin(); it != v.end(); ++it) \{ \}}
  \end{itemize}
\end{itemize}

\subsection{std::list}
\label{subsec:std_list}
Contenedor de secuencia que permite inserciones y eliminaciones en cualquier posición en tiempo constante. 

\subsubsection*{Formas de definirlo:}
\begin{itemize}
  \item Syntaxis genérica: \texttt{std::list<type> name;}
\end{itemize}

\subsubsection*{Funciones miembro:}
\begin{itemize}
  \item \texttt{push\_back(value)}: Agrega un elemento al final [O(1)].
  \item \texttt{push\_front(value)}: Agrega un elemento al principio [O(1)].
  \item \texttt{pop\_back()}: Elimina el último elemento [O(1)].
  \item \texttt{pop\_front()}: Elimina el primer elemento [O(1)].
  \item \texttt{size()}: Retorna la cantidad de elementos [O(n)].
  \item \texttt{empty()}: Retorna \texttt{true} si está vacío [O(1)].
  \item \texttt{clear()}: Elimina todos los elementos [O(n)].
  \item \texttt{front()}: Retorna el primer elemento [O(1)].
  \item \texttt{back()}: Retorna el último elemento [O(1)].
  \item \texttt{insert(iterator, value, r)}: Inserta un elemento en la posición indicada [O(r)].
  \item \texttt{erase(iterator)}: Elimina el elemento en la posición indicada [O(1)]. 
\end{itemize}

\subsection{std::stack}
\label{subsec:std_stack}
Contenedor de tipo LIFO (Last In, First Out). 

\subsubsection*{Formas de definirlo:}
\begin{itemize}
  \item Syntaxis genérica: \texttt{std::stack<type> name;}
\end{itemize}

\subsubsection*{Funciones miembro:}
\begin{itemize}
  \item \texttt{push(value)}: Agrega un elemento al tope [O(1)].
  \item \texttt{pop()}: Elimina el elemento del tope [O(1)].
  \item \texttt{top()}: Retorna el elemento del tope [O(1)].
  \item \texttt{size()}: Retorna la cantidad de elementos [O(1)].
  \item \texttt{empty()}: Retorna \texttt{true} si está vacío [O(1)]. 
\end{itemize}

\subsection{std::queue}
\label{subsec:std_queue}
Contenedor de tipo FIFO (First In, First Out). 

\subsubsection*{Formas de definirlo:}
\begin{itemize}
  \item Syntaxis genérica: \texttt{std::queue<type> name;}
\end{itemize}

\subsubsection*{Funciones miembro:}
\begin{itemize}
  \item \texttt{push(value)}: Agrega un elemento al final [O(1)].
  \item \texttt{pop()}: Elimina el primer elemento [O(1)].
  \item \texttt{front()}: Retorna el primer elemento [O(1)].
  \item \texttt{back()}: Retorna el último elemento [O(1)].
  \item \texttt{size()}: Retorna la cantidad de elementos [O(1)].
  \item \texttt{empty()}: Retorna \texttt{true} si está vacío [O(1)]. 
\end{itemize}

\subsection{std::priority\_queue}
\label{subsec:std_priority_queue}
Cola de prioridad. Su funcionamiento es similar a una cola, pero los elementos son extraídos en orden de prioridad. Para definirla hay que especificar el tipo de dato y el contenedor que se usará internamente y el comparador (\ref{subsec:comparador}).

\subsubsection*{Formas de definirlo:}
\begin{itemize}
  \item Syntaxis genérica: \texttt{std::priority\_queue<type> name;}
  \item Syntaxis con comparador: \texttt{std::priority\_queue<type, std::vector<type>, std::greater<type>> name;}
\end{itemize}

\subsection{Heap}
\label{subsec:heap}
% Explicacion
Estructura de datos que permite mantener un conjunto de elementos y obtener el máximo o mínimo en tiempo constante. 

\subsubsection*{Formas de definirlo:}
\begin{itemize}
  \item Syntaxis genérica: \texttt{std::priority\_queue<type> name;}
  \item Para un heap mínimo: \texttt{std::priority\_queue<type, std::vector<type>, std::greater<type>> name;}
\end{itemize}

\subsubsection*{Funciones miembro:}
\begin{itemize}
  \item \texttt{push(value)}: Agrega un elemento al heap [O(log n)].
  \item \texttt{pop()}: Elimina el elemento del tope [O(log n)].
  \item \texttt{top()}: Retorna el elemento del tope [O(1)].
  \item \texttt{size()}: Retorna la cantidad de elementos [O(1)].
  \item \texttt{empty()}: Retorna \texttt{true} si está vacío [O(1)]. 
\end{itemize}


\subsection{std::set}
\label{subsec:std_set}
% Explicacion
Contenedor que almacena elementos únicos ordenados. 

\subsubsection*{Formas de definirlo:}
\begin{itemize}
  \item Syntaxis genérica: \texttt{std::set<type> name;}
  \item Con comparador: \texttt{std::set<type, comp> name;}
\end{itemize}

\subsubsection*{Funciones miembro:}
\begin{itemize}
  \item \texttt{insert(value)}: Inserta un elemento [O(log n)]. 
  \item \texttt{erase(value)}: Elimina el elemento con valor 'value' [O(log n)].
  \item \texttt{erase(iterator)}: Elimina el elemento en la posición indicada [O(1)].
  \item \texttt{erase(first, last)}: Elimina los elementos en el rango [O(n)].
  \item \texttt{find(value)}: Retorna un iterador al elemento con valor 'value' [O(log n)]. 
  \item \texttt{count(value)}: Retorna la cantidad de elementos con valor 'value' [O(log n)]. 
  \item \texttt{size()}: Retorna la cantidad de elementos [O(1)]. 
  \item \texttt{empty()}: Retorna \texttt{true} si está vacío [O(1)]. 
  \item \texttt{clear()}: Elimina todos los elementos [O(n)]. 
\end{itemize}

\subsection{std::unordered\_set}
\label{subsec:std_unordered_set}
% Explicacion
Contenedor que almacena elementos únicos sin ordenar. 

\subsubsection*{Formas de definirlo:}
\begin{itemize}
  \item Syntaxis genérica: \texttt{std::unordered\_set<type> name;}
  \item Con comparador: \texttt{std::unordered\_set<type, comp> name;}
\end{itemize}

\subsubsection*{Funciones miembro:}
\begin{itemize}
  \item \texttt{insert(value)}: Inserta un elemento [O(log n)]. 
  \item \texttt{erase(value)}: Elimina el elemento con valor 'value' [O(log n)].
  \item \texttt{erase(iterator)}: Elimina el elemento en la posición indicada [O(1)].
  \item \texttt{erase(first, last)}: Elimina los elementos en el rango [O(n)].
  \item \texttt{find(value)}: Retorna un iterador al elemento con valor 'value' [O(log n)]. 
  \item \texttt{count(value)}: Retorna la cantidad de elementos con valor 'value' [O(log n)]. 
  \item \texttt{size()}: Retorna la cantidad de elementos [O(1)]. 
  \item \texttt{empty()}: Retorna \texttt{true} si está vacío [O(1)]. 
  \item \texttt{clear()}: Elimina todos los elementos [O(n)]. 
\end{itemize}

\subsection{std::map}
\label{subsec:std_map}
% Explicacion
Contenedor que almacena pares clave-valor ordenados por la clave. La función del comparador es comparar las claves de los elementos, esto sirve para mantener el orden de los elementos.

\subsubsection*{Formas de definirlo:}
\begin{itemize}
  \item Syntaxis genérica: \texttt{std::map<key, value> name;}
  \item Con comparador: \texttt{std::map<key, value, comp> name;}
\end{itemize}

\subsubsection*{Funciones miembro:}
\begin{itemize}
  \item \texttt{operator[key]}: Retorna el valor asociado a la clave 'key' [O(log n)].
  \item \texttt{insert(pair)}: Inserta un par clave-valor [O(log n)]. 
  \item \texttt{erase(key)}: Elimina el elemento con clave 'key' [O(log n)].
  \item \texttt{erase(iterator)}: Elimina el elemento en la posición indicada [O(1)].
  \item \texttt{erase(first, last)}: Elimina los elementos en el rango [O(n)].
  \item \texttt{find(key)}: Retorna un iterador al elemento con clave 'key' [O(log n)]. 
  \item \texttt{count(key)}: Retorna la cantidad de elementos con clave 'key' [O(log n)]. 
  \item \texttt{size()}: Retorna la cantidad de elementos [O(1)]. 
  \item \texttt{empty()}: Retorna \texttt{true} si está vacío [O(1)]. 
  \item \texttt{clear()}: Elimina todos los elementos [O(n)]. 
\end{itemize}

\subsection{std::unordered\_map}
\label{subsec:std_unordered_map}
% Explicacion
Contenedor que almacena pares clave-valor sin ordenar. 

\subsubsection*{Formas de definirlo:}
\begin{itemize}
  \item Syntaxis genérica: \texttt{std::unordered\_map<key, value> name;}
  \item Con comparador: \texttt{std::unordered\_map<key, value, comp> name;}
\end{itemize}

\subsubsection*{Funciones miembro:}
\begin{itemize}
  \item \texttt{operator[key]}: Retorna el valor asociado a la clave 'key' [O(log n)].
  \item \texttt{insert(pair)}: Inserta un par clave-valor [O(log n)]. 
  \item \texttt{erase(key)}: Elimina el elemento con clave 'key' [O(log n)].
  \item \texttt{erase(iterator)}: Elimina el elemento en la posición indicada [O(1)].
  \item \texttt{erase(first, last)}: Elimina los elementos en el rango [O(n)].
  \item \texttt{find(key)}: Retorna un iterador al elemento con clave 'key' [O(log n)]. 
  \item \texttt{count(key)}: Retorna la cantidad de elementos con clave 'key' [O(log n)]. 
  \item \texttt{size()}: Retorna la cantidad de elementos [O(1)]. 
  \item \texttt{empty()}: Retorna \texttt{true} si está vacío [O(1)]. 
  \item \texttt{clear()}: Elimina todos los elementos [O(n)]. 
\end{itemize}

\subsection{std::deque}
\label{subsec:std_deque}
% Explicacion
Contenedor de secuencia que permite inserciones y eliminaciones en cualquier posición en tiempo constante.

\subsubsection*{Formas de definirlo:}
\begin{itemize}
  \item Syntaxis genérica: \texttt{std::deque<type> name;}
\end{itemize}

\subsubsection*{Funciones miembro:}
\begin{itemize}
  \item \texttt{push\_back(value)}: Agrega un elemento al final [O(1)].
  \item \texttt{push\_front(value)}: Agrega un elemento al principio [O(1)].
  \item \texttt{pop\_back()}: Elimina el último elemento [O(1)].
  \item \texttt{pop\_front()}: Elimina el primer elemento [O(1)].
  \item \texttt{size()}: Retorna la cantidad de elementos [O(1)].
  \item \texttt{empty()}: Retorna \texttt{true} si está vacío [O(1)].
  \item \texttt{clear()}: Elimina todos los elementos [O(n)].
  \item \texttt{front()}: Retorna el primer elemento [O(1)].
  \item \texttt{back()}: Retorna el último elemento [O(1)].
  \item \texttt{insert(iterator, value)}: Inserta un elemento en la posición indicada [O(n)]. 
\end{itemize}

\subsection{Adjacency list}
\label{subsec:adjacency_list}
% Explicacion
Lista de adyacencia donde cada nodo tiene una lista de nodos adyacentes.

\subsubsection*{Implementacion:}
% Code
\begin{lstlisting}
const int V;
std::vector<int> adj[V];
std::vector<int> weight[V];
\end{lstlisting}

\subsubsection*{Ejemplo:}
\begin{itemize}
  \item Grafo no dirigido: \texttt{std::vector<int> Adj[V];}
  \begin{itemize}
    \item Agregar arista: \texttt{Adj[u].push\_back(v);}
  \end{itemize}
  \item Grafo con pesos: \texttt{std::vector<pair<int, int>> Adj[V];}
  \begin{itemize}
    \item Agregar arista con peso: \texttt{Adj[u].push\_back(\{v, w\});}
  \end{itemize}
  
\end{itemize}

\subsection{Union Find}
\label{subsec:union_find}
% Explicacion
Estructura de datos que permite realizar operaciones de unión y búsqueda en tiempo constante. Ideal para hacer Kruskal.

\subsubsection*{Implementacion:}
% Code
\begin{lstlisting}
struct edge{
    ll from,to,weight;
};

struct union_find {
  vector<int> e;
  union_find(int n) { e.assign(n, -1); }
  int findSet (int x) { 
    return (e[x] < 0 ? x : e[x] = findSet(e[x]));
  }
  bool sameSet (int x, int y) { return findSet(x) == findSet(y); }
  int size (int x) { return -e[findSet(x)]; }
  bool unionSet (int x, int y) {
    x = findSet(x), y = findSet(y);
    if (x == y) return 0;
    if (e[x] > e[y]) swap(x, y);
    e[x] += e[y], e[y] = x;
    return 1;
  }
};
\end{lstlisting}

\subsubsection*{Funciones miembro:}
\begin{itemize}
  \item \texttt{findSet(x)}: Retorna el representante del conjunto al que pertenece 'x' [O(1)].
  \item \texttt{sameSet(x, y)}: Retorna \texttt{true} si 'x' y 'y' pertenecen al mismo conjunto [O(1)].
  \item \texttt{size(x)}: Retorna el tamaño del conjunto al que pertenece 'x' [O(1)].
  \item \texttt{unionSet(x, y)}: Une los conjuntos a los que pertenecen 'x' y 'y' [O(1)].
\end{itemize}

